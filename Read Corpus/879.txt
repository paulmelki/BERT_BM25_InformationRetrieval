binary and the linear search algorithm which ignores ordering can be used the analysis of the former and the latter algorithm shows that it takes at most log and check steps respectively for list of length in the depicted example list of length searching for morin arthur takes and steps with binary shown in and linear search respectively graphs of functions commonly used in the analysis of algorithms showing the number of operations versus input size for each function in computer science the analysis of algorithms is the process of finding the computational complexity of algorithms the amount of time storage or other resources needed to execute them usually this involves determining function that relates the length of an algorithm input to the number of steps it takes its time complexity or the number of storage locations it uses its space complexity an algorithm is said to be efficient when this function values are small or grow slowly compared to growth in the size of the input different inputs of the same length may cause the algorithm to have different behavior so best worst and average case descriptions might all be of practical interest when not otherwise specified the function describing the performance of an algorithm is usually an upper bound determined from the worst case inputs to the algorithm the term analysis of algorithms was coined by donald knuth algorithm analysis is an important part of broader computational complexity theory which provides theoretical estimates for the resources needed by any algorithm which solves given computational problem these estimates provide an insight into reasonable directions of search for efficient algorithms in theoretical analysis of algorithms it is common to estimate their complexity in the asymptotic sense to estimate the complexity function for arbitrarily large input big notation big omega notation and big theta notation are used to this end for instance binary search is said to run in number of steps proportional to the logarithm of the length of the sorted list being searched or in log colloquially in logarithmic time usually asymptotic estimates are used because different implementations of the same algorithm may differ in efficiency however the efficiencies of any two reasonable implementations of given algorithm are related by constant multiplicative factor called hidden constant exact not asymptotic measures of efficiency can sometimes be computed but they usually require certain assumptions concerning the particular implementation of the algorithm called model of computation model of computation may be defined in terms of an abstract computer turing machine and or by postulating that certain operations are executed in unit time for example if the sorted list to which we apply binary search has elements and we can guarantee that each lookup of an element in the list can be done in unit time then at most log time units are needed to return an answer cost models time efficiency estimates depend on what we define to be step for the analysis to correspond usefully to the actual execution time the time required to perform step must be guaranteed to be bounded above by constant one must be careful here for instance some analyses count an addition of two numbers as one step this assumption may not be warranted in certain contexts for example if the numbers involved in computation may be arbitrarily large the time required by single addition can no longer be assumed to be constant two cost models are generally used the uniform cost model also called uniform cost measurement and similar variations assigns constant cost to every machine operation regardless of the size of the numbers involved the logarithmic cost model also called logarithmic cost measurement and similar variations assigns cost to every machine operation proportional to the number of bits involved the latter is more cumbersome to use so it only employed when necessary for example in the analysis of arbitrary precision arithmetic algorithms like those used in cryptography key point which is often overlooked is that published lower bounds for problems are often given for model of computation that is more restricted than the set of operations that you could use in practice and therefore there are algorithms that are faster than what would naively be thought possible run time analysis run time analysis is theoretical classification that estimates and anticipates the increase in running time or run time of an algorithm as its input size usually denoted as increases run time efficiency is topic of great interest in computer science program can take seconds hours or even years to finish executing depending on which algorithm it implements while software profiling techniques can be used to measure an algorithm run time in practice they cannot provide timing data for all infinitely many possible inputs the latter can only be achieved by the theoretical methods of run time analysis shortcomings of empirical metrics since algorithms are platform independent given algorithm can be implemented in an arbitrary programming language on an arbitrary computer running an arbitrary operating system there are additional significant drawbacks to using an empirical approach to gauge the comparative performance of given set of algorithms take as an example program that looks up specific entry in sorted list of size suppose this program were implemented on computer state of the art machine using linear search algorithm and on computer much slower machine using binary search algorithm benchmark testing on the two computers running their respective programs might look something like the following list size computer run time in nanoseconds computer run time in nanoseconds based on these metrics it would be easy to jump to the conclusion that computer is running an algorithm that is far superior in efficiency to that of computer however if the size of the input list is increased to sufficient number that conclusion is dramatically demonstrated to be in error list size computer run time in nanoseconds computer run time in nanoseconds ns or year ns or milliseconds computer running the linear search program exhibits linear growth rate the